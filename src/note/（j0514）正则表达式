正则表达式
一种强大的字符串处理工具，可以对字符串进行查找、提取、分割、替换等操作。
主要方法如下：
1.boolean matches(String regex)
判断该字符串是否匹配指定的正则表达式

2.String replaceAll(String regex,String replacement)
所有替换

3.String replaceFirst(String regex,String replacement)
从开始替换

4.String [] split(String regex)
根据给的正则表达式拆开该字符串后得到的字符串数组


\xhhhh：表示十六进制
\n：
\t：制表符
\u：
\r：
\f：换页符
\d：匹配0-9的所有数字
\w：匹配所有单词字符，包括0-9所有数字，26个英文字母和下划线（_）
\b：单词的边界
()：子表达式
$：找到一行的结尾，正则结束。（要使用$本身，使用\$）
^：找到一行的开头，正则开始。（要使用^本身，使用\^）
[]：表示枚举，[abc]（a、b、c中的任意字符）
[-]：表示范围，[a-z]（a到z中的任意字符）
[^]：表示否，[^abc]（a、b、c以外的任意字符）
[&&]：表示与运算，

{}：出现的频度
+：1次或多次
*：0次或多次
?：0次或1次
\：转义。（要使用\本身，使用\\）
.：除了\n之外的任何合法字符
|：或
,：{1,}（1次及以上）、{90,}（90次及以上）



// 反斜杠
/t 间隔 ('/u0009')
/n 换行 ('/u000A')
/r 回车 ('/u000D')
/d 数字 等价于[0-9]
/D 非数字 等价于[^0-9]
/s 空白符号 [/t/n/x0B/f/r]
/S 非空白符号 [^/t/n/x0B/f/r]
/w 单独字符 [a-zA-Z_0-9]
/W 非单独字符 [^a-zA-Z_0-9]
/f 换页符
/e Escape
/b 一个单词的边界
/B 一个非单词的边界
/G 前一个匹配的结束

^ 找到一行的开头，要使用^本身，使用\^
^java     条件限制为以Java为开头字符
$ 找到一行的结尾，要使用$本身，使用\$
java$     条件限制为以java为结尾字符
.  条件限制除/n以外任意一个单独字符
java..     条件限制为java后除换行外任意两个字符


加入特定限制条件「[]」
[a-z]     条件限制在小写a to z范围中一个字符
[A-Z]     条件限制在大写A to Z范围中一个字符
[a-zA-Z] 条件限制在小写a to z或大写A to Z范围中一个字符
[0-9]     条件限制在小写0 to 9范围中一个字符
[0-9a-z] 条件限制在小写0 to 9或a to z范围中一个字符
[0-9[a-z]] 条件限制在小写0 to 9或a to z范围中一个字符(交集)

[]中加入^后加再次限制条件「[^]」
[^a-z]     条件限制在非小写a to z范围中一个字符
[^A-Z]     条件限制在非大写A to Z范围中一个字符
[^a-zA-Z] 条件限制在非小写a to z或大写A to Z范围中一个字符
[^0-9]     条件限制在非小写0 to 9范围中一个字符
[^0-9a-z] 条件限制在非小写0 to 9或a to z范围中一个字符
[^0-9[a-z]] 条件限制在非小写0 to 9或a to z范围中一个字符(交集)

在限制条件为特定字符出现0次以上时，可以使用「*」
J*     0个以上J
.*     0个以上任意字符
J.*D     J与D之间0个以上任意字符

在限制条件为特定字符出现1次以上时，可以使用「+」
J+     1个以上J
.+     1个以上任意字符
J.+D     J与D之间1个以上任意字符

在限制条件为特定字符出现有0或1次以上时，可以使用「?」
JA?     J或者JA出现

限制为连续出现指定次数字符「{a}」
J{2}     JJ
J{3}     JJJ
文字a个以上，并且「{a,}」
J{3,}     JJJ,JJJJ,JJJJJ,???(3次以上J并存)
文字个以上，b个以下「{a,b}」
J{3,5}     JJJ或JJJJ或JJJJJ
两者取一「|」
J|A     J或A
Java|Hello     Java或Hello
 
「()」中规定一个组合类型
比如，我查询<a href=/"index.html/">index</a>中<a href></a>间的数据，可写作<a.*href=/".*/">(.+?)</a>

在使用Pattern.compile函数时，可以加入控制正则表达式的匹配行为的参数：
Pattern Pattern.compile(String regex, int flag)

flag的取值范围如下：
Pattern.CANON_EQ     当且仅当两个字符的"正规分解(canonical decomposition)"都完全相同的情况下，才认定匹配。比如用了这个标志之后，表达式"a/u030A"会匹配"?"。默认情况下，不考虑"规范相等性(canonical equivalence)"。
Pattern.CASE_INSENSITIVE(?i)     默认情况下，大小写不明感的匹配只适用于US-ASCII字符集。这个标志能让表达式忽略大小写进行匹配。要想对Unicode字符进行大小不明感的匹配，只要将UNICODE_CASE与这个标志合起来就行了。
Pattern.COMMENTS(?x)     在这种模式下，匹配时会忽略(正则表达式里的)空格字符(译者注：不是指表达式里的"//s"，而是指表达式里的空格，tab，回车之类)。注释从#开始，一直到这行结束。可以通过嵌入式的标志来启用Unix行模式。
Pattern.DOTALL(?s)     在这种模式下，表达式'.'可以匹配任意字符，包括表示一行的结束符。默认情况下，表达式'.'不匹配行的结束符。
Pattern.MULTILINE
(?m)     在这种模式下，'^'和'$'分别匹配一行的开始和结束。此外，'^'仍然匹配字符串的开始，'$'也匹配字符串的结束。默认情况下，这两个表达式仅仅匹配字符串的开始和结束。
Pattern.UNICODE_CASE
(?u)     在这个模式下，如果你还启用了CASE_INSENSITIVE标志，那么它会对Unicode字符进行大小写不明感的匹配。默认情况下，大小写不敏感的匹配只适用于US-ASCII字符集。
Pattern.UNIX_LINES(?d)     在这个模式下，只有'/n'才被认作一行的中止，并且与'.'，'^'，以及'$'进行匹配。